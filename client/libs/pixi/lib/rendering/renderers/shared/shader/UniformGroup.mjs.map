{"version":3,"file":"UniformGroup.mjs","sources":["../../../../../src/rendering/renderers/shared/shader/UniformGroup.ts"],"sourcesContent":["import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, type UniformData } from './types';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @memberof rendering\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n\n    noTypes: boolean\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types {@link UNIFORM_TYPES}\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```glsl\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n *\n *\n *  ```\n * @memberof rendering\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n        noTypes: false\n    };\n\n    /** used internally to know if a uniform group was used in the last render pass */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('uniform');\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    public _resourceType = 'uniformGroup';\n    /** the resource id used internally by the renderer to build bind group keys */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     * @ignore\n     */\n    public _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param _uniformStructures\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(_uniformStructures: UNIFORMS | Record<string, unknown>, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        const noTypes = hasTypes(_uniformStructures);\n\n        // if(_uniformStructures.)\n        if (noTypes)\n        {\n            const uniforms = _uniformStructures as Record<string, unknown>;\n\n            this.uniforms = uniforms as any;\n\n            this.uniformStructures = {};\n\n            // uniform structures will be figured out later!\n        }\n        else\n        {\n            const uniformStructures = _uniformStructures as UNIFORMS;\n\n            const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n            for (const i in uniformStructures)\n            {\n                const uniformData = uniformStructures[i] as UniformData;\n\n                uniformData.name = i;\n                uniformData.size ??= 1;\n\n                if (!UNIFORM_TYPES_MAP[uniformData.type])\n                {\n                // eslint-disable-next-line max-len\n                    throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(', ')}`);\n                }\n\n                uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n                uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n            }\n\n            this.uniformStructures = uniformStructures;\n            this.uniforms = uniforms;\n        }\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n    }\n\n    get signature()\n    {\n        // if (!this._signature)\n        {\n            const uniformStructures = this.uniformStructures;\n\n            this._signature = createIdFromString(Object.keys(uniformStructures).map(\n                (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n            ).join('-'), 'uniform-group');\n        }\n\n        return this._signature;\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\nfunction hasTypes<T extends Record<string, { type: string }>>(_uniformStructures: T)\n{\n    for (const i in _uniformStructures)\n    {\n        if (!_uniformStructures[i]?.type)\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n"],"names":[],"mappings":"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"}